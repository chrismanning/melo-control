// Do not edit. Generated by gurkle v0.3.0 <https://github.com/technocreatives/gurkle>

pub mod get_collection {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "GetCollection";
    pub const QUERY : & str = "query GetCollection($idEq: String!) {\n  library {\n    collections(where: {id: {EqExpr: {eq: $idEq}, inputname: EqExpr}}) {\n      id\n      name\n      sourceGroups {\n        sources {\n          id\n          metadata {\n            mappedTags {\n              artistName\n              trackNumber\n              trackTitle\n            }\n          }\n          downloadUri\n        }\n        groupTags {\n          albumArtist\n          albumTitle\n          date\n          discNumber\n          genre\n          totalDiscs\n        }\n      }\n    }\n  }\n}\n" ;
    #[allow(unused_imports)]
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Variables {
        #[serde(rename = "idEq")]
        pub id_eq: String,
    }
    impl Variables {}
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
    pub struct GetCollection {
        pub library: GetCollectionLibrary,
    }
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
    pub struct GetCollectionLibrary {
        pub collections: Vec<GetCollectionLibraryCollections>,
    }
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
    pub struct GetCollectionLibraryCollections {
        pub id: String,
        pub name: String,
        #[serde(rename = "sourceGroups")]
        pub source_groups: Vec<GetCollectionLibraryCollectionsSourceGroups>,
    }
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
    pub struct GetCollectionLibraryCollectionsSourceGroups {
        pub sources: Vec<GetCollectionLibraryCollectionsSourceGroupsSources>,
        #[serde(rename = "groupTags")]
        pub group_tags: GetCollectionLibraryCollectionsSourceGroupsGroupTags,
    }
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
    pub struct GetCollectionLibraryCollectionsSourceGroupsSources {
        pub id: String,
        pub metadata: GetCollectionLibraryCollectionsSourceGroupsSourcesMetadata,
        #[serde(rename = "downloadUri")]
        pub download_uri: String,
    }
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
    pub struct GetCollectionLibraryCollectionsSourceGroupsSourcesMetadata {
        #[serde(rename = "mappedTags")]
        pub mapped_tags: GetCollectionLibraryCollectionsSourceGroupsSourcesMetadataMappedTags,
    }
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
    pub struct GetCollectionLibraryCollectionsSourceGroupsSourcesMetadataMappedTags {
        #[serde(rename = "artistName")]
        pub artist_name: Option<Vec<String>>,
        #[serde(rename = "trackNumber")]
        pub track_number: Option<String>,
        #[serde(rename = "trackTitle")]
        pub track_title: Option<String>,
    }
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
    pub struct GetCollectionLibraryCollectionsSourceGroupsGroupTags {
        #[serde(rename = "albumArtist")]
        pub album_artist: Option<Vec<String>>,
        #[serde(rename = "albumTitle")]
        pub album_title: Option<String>,
        pub date: Option<String>,
        #[serde(rename = "discNumber")]
        pub disc_number: Option<String>,
        pub genre: Option<Vec<String>>,
        #[serde(rename = "totalDiscs")]
        pub total_discs: Option<String>,
    }
    impl Variables {
        pub async fn execute<'a>(
            &'a self,
            client: &'a dyn gurkle::Executor<'a, GetCollection>,
        ) -> Result<GetCollection, gurkle::Error> {
            let req_body = gurkle::RequestBody {
                variables: serde_json::to_value(&self)?,
                query: QUERY,
                operation_name: OPERATION_NAME,
            };
            client.execute(req_body).await
        }
    }
    impl GetCollection {
        pub fn map<T, F: FnOnce(Self) -> T>(self, f: F) -> T {
            (f)(self)
        }
    }
}
pub use get_collection::GetCollection;
pub use get_collection::Variables as GetCollectionRequest;
pub mod get_collections {
    #![allow(dead_code)]
    use std::result::Result;
    pub const OPERATION_NAME: &str = "GetCollections";
    pub const QUERY : & str = "query GetCollections {\n  library {\n    collections {\n      id\n      name\n      kind\n      rootUri\n    }\n  }\n}\n" ;
    #[allow(unused_imports)]
    use super::*;
    use serde::{Deserialize, Serialize};
    #[allow(dead_code)]
    type Boolean = bool;
    #[allow(dead_code)]
    type Float = f64;
    #[allow(dead_code)]
    type Int = i64;
    #[allow(dead_code)]
    type ID = String;
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Variables;
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
    pub struct GetCollections {
        pub library: GetCollectionsLibrary,
    }
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
    pub struct GetCollectionsLibrary {
        pub collections: Vec<GetCollectionsLibraryCollections>,
    }
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
    pub struct GetCollectionsLibraryCollections {
        pub id: String,
        pub name: String,
        pub kind: String,
        #[serde(rename = "rootUri")]
        pub root_uri: String,
    }
    impl Variables {
        pub async fn execute<'a>(
            &'a self,
            client: &'a dyn gurkle::Executor<'a, GetCollections>,
        ) -> Result<GetCollections, gurkle::Error> {
            let req_body = gurkle::RequestBody {
                variables: serde_json::to_value(&self)?,
                query: QUERY,
                operation_name: OPERATION_NAME,
            };
            client.execute(req_body).await
        }
    }
    impl GetCollections {
        pub fn map<T, F: FnOnce(Self) -> T>(self, f: F) -> T {
            (f)(self)
        }
    }
}
pub use get_collections::GetCollections;
pub use get_collections::Variables as GetCollectionsRequest;
